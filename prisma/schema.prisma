generator client {
  provider = "prisma-client"
  output   = "../src/generated"
}

datasource db {
  provider = "postgresql"
}

model User {
  id            String    @id @default(uuid())
  walletAddress String?
  gender        String?
  ipAddress     String?
  avatarUrl     String?
  interests     String[]
  isPro         Boolean   @default(false)
  proEnd        DateTime?
  isBanned      Boolean   @default(false)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  initiatedCalls     Call[]             @relation("initiator_calls")
  receivedCalls      Call[]             @relation("receiver_calls")
  sentTexts          Text[]             @relation("sender_texts")
  receivedTexts      Text[]             @relation("receiver_texts")
  userFriendships    Friendship[]       @relation("user_friends")
  friendFriendships  Friendship[]       @relation("friend_user")
  reportsMade        Report[]           @relation("reporter")
  reportsReceived    Report[]           @relation("reported_user")
  leaderboardEntries LeaderboardEntry[]
  subscriptions      Subscription[]
  pointActivity      PointActivity[]
  ratings            Rating[]           @relation("user_ratings")
  ratedRatings       Rating[]           @relation("rated_user_ratings")
  notifications      Notification[]
  LuckyWinnerEntry   LuckyWinnerEntry[]
  name               String
  email              String
  emailVerified      Boolean            @default(false)
  image              String?
  sessions           Session[]
  accounts           Account[]

  // username    String
  role        String?   @default("user")
  banned      Boolean?  @default(false)
  banReason   String?
  banExpires  DateTime?
  isAnonymous Boolean?

  username String?

  displayUsername String?

  @@unique([email])
  @@unique([username])
  @@map("user")
}

model Rating {
  id          String   @id @default(uuid())
  userId      String
  ratedUserId String
  rating      Int
  createdAt   DateTime @default(now())

  // Relations
  user      User @relation("user_ratings", fields: [userId], references: [id])
  ratedUser User @relation("rated_user_ratings", fields: [ratedUserId], references: [id])
}

model Call {
  id               String   @id @default(uuid())
  initiatorId      String
  receiverId       String
  durationSec      Int
  startedAt        DateTime
  endedAt          DateTime
  ratedByInitiator Int?
  ratedByReceiver  Int?

  // Relations
  initiator User? @relation("initiator_calls", fields: [initiatorId], references: [id])
  receiver  User? @relation("receiver_calls", fields: [receiverId], references: [id])
}

model Text {
  id String @id @default(uuid())

  senderId   String?
  receiverId String?

  senderAnonId   String
  receiverAnonId String

  content String
  sentAt  DateTime @default(now())
  roomId  String

  // Relations
  sender   User? @relation("sender_texts", fields: [senderId], references: [id])
  receiver User? @relation("receiver_texts", fields: [receiverId], references: [id])
  room     Room  @relation(fields: [roomId], references: [id])
}

model Friendship {
  id        String   @id @default(uuid())
  userId    String
  friendId  String
  accepted  Boolean  @default(false)
  createdAt DateTime @default(now())

  user   User @relation("user_friends", fields: [userId], references: [id], onDelete: Cascade)
  friend User @relation("friend_user", fields: [friendId], references: [id], onDelete: Cascade)

  @@unique([userId, friendId])
}

model Report {
  id             String   @id @default(uuid())
  reporterId     String
  reportedUserId String
  reason         String
  createdAt      DateTime @default(now())

  // Relations
  reporter     User @relation("reporter", fields: [reporterId], references: [id])
  reportedUser User @relation("reported_user", fields: [reportedUserId], references: [id])
}

model LeaderboardEntry {
  id       String   @id @default(uuid())
  userId   String
  date     DateTime
  score    Float
  eligible Boolean  @default(true)

  // Relations
  user User @relation(fields: [userId], references: [id])

  @@unique([userId, date])
}

model LuckyWinnerEntry {
  id        String   @id @default(uuid())
  userId    String
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id])
}

model Subscription {
  id        String   @id @default(uuid())
  userId    String
  plan      Plan
  startedAt DateTime @default(now())
  expiresAt DateTime
  paymentId String?  @unique

  // Relations
  user User @relation(fields: [userId], references: [id])
}

model Room {
  id          String   @id @default(uuid())
  type        RoomType
  user1Id     String? // references User
  anonUser1Id String? // fallback for anonymous user
  user2Id     String?
  anonUser2Id String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  messages Text[]

  @@index([user1Id])
  @@index([user2Id])
  @@index([anonUser1Id])
  @@index([anonUser2Id])
}

model PointActivity {
  id        String   @id @default(uuid())
  userId    String
  point     Int
  createdAt DateTime @default(now())
  User      User     @relation(fields: [userId], references: [id])
}

model Notification {
  id        String               @id @default(uuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  data      Json? // Additional data for the notification
  isSent    Boolean              @default(false) // read is handled by the client
  createdAt DateTime             @default(now())
  sentAt    DateTime?
  readAt    DateTime?
  priority  NotificationPriority @default(NORMAL)

  // Relations
  user User @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([createdAt])
}

enum NotificationType {
  FRIEND_REQUEST
  FRIEND_ACCEPTED
  NEW_MESSAGE
  CALL_INCOMING
  CALL_MISSED
  SYSTEM_ANNOUNCEMENT
  POINTS_EARNED
  ACHIEVEMENT_UNLOCKED
  SUBSCRIPTION_EXPIRING
  SUBSCRIPTION_EXPIRED
  MATCH_FOUND
}

enum Plan {
  MONTHLY
  YEARLY
}

enum RoomType {
  CHAT
  CALL
  VIDEO_CALL
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  impersonatedBy String?

  @@unique([token])
  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now()) @updatedAt

  @@index([identifier])
  @@map("verification")
}

enum NotificationPriority {
  LOW
  NORMAL
  HIGH
}
